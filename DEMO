# A step-by-step project that demonstrates the use of this bundle.

In this demo we'll create a blog; because that's what blogs are form: being 
demonstrations of web frameworks.

The demonstration uses new features of Rails 2.0 and the snippets in this bundle.

## A New App

    rails blog
    cd blog
    mate .

## Add some models

    ruby script/generate model Post subject:string body:text
    
This creates a 001_create_post migration with a create_table:

    create_table :posts do |t|
      t.string :subject
      t.text :body

      t.timestamps
    end
    
## Sexy Migration support

If you put the cursor on the line after `t.text :body`, type `t.` and press TAB. Select "Create boolean column", and type "published" into the template field.

Note that another `t.` was created on the next line! Press TAB and the cursor will be placed after it. You can now press TAB again to create another column, or delete this line.

Here, delete the extraneous `t.` line.

Run the migrations:

    rake db:migrate
    
## Post fixtures

Update the `test/fixtures/posts.yml` file as:

    published:
      subject: Some article
      body: A test article
      published: true

    nonpublished:
      body: Still writing this one

Note, in Rails 2.0 fixtures no longer have explicit ids. Later on we'll look at snippets for using Foxy Fixtures with auto-completion for associations.

## Public blog controller

    ruby script/generate controller blog
    
Now open `blog_controller_test.rb`. Note how much cleaner functional tests are now via `ActionController::TestCase`. 

Let's do some TDD. First, delete the `test_truth` dummy method. 

To create a test to show a list of blog articles:

    deftg

and TAB gives:

    def test_should_get_action
      get :action, :id => @object
      assert_response :success

    end

Type `index` to replace `action`. Press TAB, and then DELETE to remove `:id => @object`. The press TAB again to go to the end of the method. Now we have:

    def test_should_get_index
      get :index
      assert_response :success

    end
    
Now type `asg`, press TAB, and type `posts`, and press TAB again. This creates an instance variable lookup within an assertion:

    assert(posts = assigns(:posts), "Cannot find @posts")
    
Now, let's assert the HTML format.

Type `ass` and press TAB. Type `div#posts`, press TAB and DELETE, then TAB again to place the cursor within the `assert_select` block:

    assert_select 'div#posts' do
      
    end
    
Now we'll check that the `@posts` objects are represented in the `div#posts` element.

With the cursor inside the `assert_select`:

Type `ass`, press TAB, type `div.post`, press TAB, press TAB again, and type `count` (to replace the `text`). Now press TAB again, and type `@posts.size`. Press TAB a final time (it will highlight the `do...end` block), and press DELETE.

Our test method is now finished:

    def test_should_get_index
      get :index
      assert_response :success
      assert(posts = assigns(:posts), "Cannot find @posts")
      assert_select 'div#posts' do
        assert_select 'div.post', :count => posts.size
      end
    end

NOTE: there is also a `deftp` snippet for functional tests to create a POST test stub.

## Controller actions

Now, to navigate to `blog_controller.rb` there are two options:

* press Shift+Alt+Cmd+DownArrow, and select "Controller" from the drop-down list
* press Alt+Cmd+DownArrow and you'll go directly to the controller (toggles btw the two files)

Change the `index` action method to:

    def index
      @posts = Post.find_all_by_published(true)
    end

## Action views

To create/navigate to the view, press Shift+Alt+Cmd+DownArrow and select "View" (like above).

As there is no `app/views/blog/index*` files, it will prompt you to create a blank view file. By default it guesses `index.html.erb`, but of course you can change that in the dialog box.

Press enter to accept `index.html.erb`. You are taken to the new file.

Let's create HTML to match the earlier tests.

Type `div` and press TAB twice, then type `posts` and press TAB:

    <div id="posts">

    </div>

Inside the `div` element, type `for` and press TAB. This expands into a large ERb-enabled for-loop. Type `@posts`, press TAB, type `post` and press TAB. The cursor is now inside the for-loop.

Inside the for-loop, type: `div` and press TAB. Press DELETE, and type ` class='post'` and press TAB to enter the `div` element.

Press Ctrl+> (greater-than) to create a `<%=  %>` element. If you press Ctrl+> again, it toggles to `<%  %>`, and then again and it becomes `<%-  -%>`, and again and it becomes `<%#  %>` (a Ruby comment). Pressing Ctrl+> again starts at `<%=  %>` again.

Enter `post.body` within the ERb template field.

Move the cursor down between `<% else %>` and `<% end %>`.

Press Shift+Ctrl+W to create a simple element `<p></p>`. You can change the element type here. Just press TAB to go inside the element. Type `There are no posts available to read. All y'all come back soon, yer hear.` because its funny.

Our `index.html.erb` template is now:

    <div id="posts">
      <% if !@posts.blank? %>
        <% for post in @posts %>
          <div class="post">
            <%= post.body %>
          </div>
        <% end %>
      <% else %>
        <p>There are no posts available to read. All y'all come back soon, yer hear.</p>
      <% end %>

    </div>

If we run our functional tests they now pass: `rake test:functionals`

As yet, we have no way for users to leave comments.

## Associations

Create a comment model:

    ruby script/generate model Comment body:text name:string post:references
    
Note: here `post:references` is effectively the same as `post_id:integer`. Within the generated migration it creates `t.reference :post`. There is also a `t.` snippet for references, as for other standard datatypes, which helps setup polymorphic associations.

The generated `create_table` in `002_create_comments.rb` is:

    create_table :comments do |t|
      t.text :body
      t.string :name
      t.references :post

      t.timestamps
    end
    
Run `rake db:migrate`.

Now create some comment fixtures so we can look at Foxy Fixtures. Open `text/fixtures/comments.yml`.

By default, the generated `comments.yml` starts like:

    one:
      body: MyText
      name: MyString
      post: 

    two:
      body: MyText
      name: MyString
      post: 
    
The `post` fields replace the rails1.2 `post_id` fields. Now, we can specify the `post.yml` labels for a post. From above we have `published` and `unpublished`. It can be hard to remember what fixtures we have, so there is a key-combo helper.

Put the cursor after `post: ` and press Alt+Escape. A drop-down box appears with the names of the `posts.yml` fixtures. Select `published` and press return. Repeat for the 2nd fixture. This gives us:

    one:
      body: MyText
      name: MyString
      post: published

    two:
      body: MyText
      name: MyString
      post: published
    
