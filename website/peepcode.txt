h1. Peepcode Script

h2. Introduction

Many many people's first introduction to Ruby on Rails was the 15 minute video from DHH showing how you create a blog application with Rails. Nearly everyone finished that video asking one question: what was that editor? It is awesome.

Let's take a stroll down memory lane. We pick up the action at the X minute mark:

[transition into a portion of the video that shows off TMs features, plus DHH saying "Whooops!"]

What is interesting, is that as fast as David is able to write his blog application, even with his detour demonstrating the now deleted scaffold command, he never uses any special TextMate extensions for Rails. He uses some HTML snippets and commands and some Ruby snippets and commands. The original Ruby on Rails extensions were in their infancy.

[Open Bundle Editor] A collection of TextMate extensions is called a "bundle".

When working with Rails with TextMate you'll use several "bundles":

* HTML
* Ruby
* Ruby on Rails
* JavaScript

You might also use the ProtoType, jQuery or other JavaScript bundle if you use those libraries.

Ruby on Rails 2.0 was recently released and includes many improvements to
* the syntax that you type [<code>redirect_to :action => 'show', :id => @person</code> became <code>redirect_to @person</code>]
* changes to some file extensions [rhtml -> html.erb] and
* changes to some file name conventions [user_controller.rb -> users_controller.rb, more commonly].

The Ruby on Rails bundle has also been given a major upgrade to match all the changes for developing Rails 2.0 applications.

The snippets and commands we're going to look at are actually described across all three bundles. Often it is the Rails bundle that reuses the HTML and Ruby bundles. For example, in an HTML file you have a variety of ways to create new elements. [examples] Within an html.erb file you can reuse all the same snippets and commands.


h2. Know thy Editor

Overview key icons (see PeepCode TM video)

Preferences > Advanced > Folder References > Folder Patterns: add 'vendor/rails' and it will ignore that folder in any project - both from the Dock and from Search.

h2. Models and Migrations

* Create new app
* Go to app/controllers/application.rb (need a Ruby on Rails file)
* ^| + 1 - Call Generate Script - create new model "Post"  TODO - not working @ moment
  OR CLI:script/generate model Post title:string
* Go to migration file: Cmd+T + 001
* t. - list of available sexy migration columns; when selecting one, another t. is automatically created for you. (create body:text + published:boolean)
* Shft+^+K - remove a line
* CLI:script/generate model Comment
* Cmd+T + 002 - comment migration + add t.references :post, body:text, name:string
* Ctrl+| + 3 - run migrations
  * See error?
  * In terminal, go to "/Applications/TextMate.app/Contents/SharedSupport/Support/lib" and rename/remove Builder.rb
  * Run migrations again

* Go to post.rb
  * hm + comments; notice you can tab across to change fields if required
  * Also, hmt -> for has_many :through*
* Go to comments.rb
  * bt + post; notice the autocompletions are correct here, but still optional for rails so can be deleted
  * vp + name, body
  * [Ctrl-Esc -> Models] All the validations are available as snippets based on the first letter of each word.
* Place the cursor on 'Comment' class name, Sft+Ctrl+Cmd+S -> shows schema for this class. Alternately, place it on 'post' to get the schema for Post class.

h2. Testing

I'll talk more about navigating between files in a Rails application later, but for the moment, know that there is a special relationship between a model file and a unit test file. You can toggle between them with Alt+Cmd+DownArrow.

The Rails generator for models created this unit test file and a fixtures file.

First, let's set up some fixtures for posts and comments. Go to posts.yml and create a "published" and a "unpublished" fixture. Now go to comments.yml - using Ctrl+Cmd+R to show posts.yml in the dock.

TODO - how to move focus from editor to dock?

Within comments, create one comment:

<pre>valid:
  name: Dr Nic
  body: Cool post
  post:</pre>

With Rails 2.0, your fixture ids are no longer required, and you can use Foxy Fixtures to select an associated fixture. Here we'd type 'published' to reference that posts.yml fixture. But, since the column name is 'post' we can get a drop-down list using Alt+Esc. We'll use this same fixture autocompletion feature again within the test files.

Back to the comments unit test, and that dummy test needs removing.

Create a new test method with <code>deft</code> + <code>should_require_title</code>.

Type <code>posts(:)</code> and Alt+Esc to access the fixtures autocompletion. You can now select a posts.yml fixture. Note, the current implementation replaces the whole line, so if you need multiple or want a different instance variable you'll need to make some manual changes.

Finished:

<pre syntax="ruby">def test_should_require_title
  @post = posts(:published)
  @comment = @post.comments.create
  @comment.valid?
  assert(@comment.errors[:name], "Should be errors for name field")
end</pre>

To run your unit tests, Ctrl-\ + 'Test Units' or 'Test Recent'.

In order to write some functional tests for our blog, let's generate a controller as it generates the functional test at the same time. [Ctrl-|] We won't specify any actions for the moment, and we'll clean away the open windows for the controller and the helper.

For now, let's write some functional tests. [remove the test_truth method]

h3. Diagram

* deftg -> test GET action
* deftp -> test POST action

Since many functional tests start with the same setup, there are two functional test snippets to write tests faster. The last letter maps the the http method to be used for the test: g for GET and p for POST.

To create a test for the index action, use <code>deftg + 'index'</code>. Then delete the two optional @model sections.

Next, to load an instance variable into the test, type <code>asg + 'posts'</code>

Now, let's assert the HTML format.

Type <code>ass</code> and press TAB. Type <code>div#posts</code>, press TAB and DELETE, then TAB twice to place the cursor within the <code>assert_select</code> block:

<pre syntax="ruby">assert_select 'div#posts' do

end</pre>

Now we'll check that the <code>@posts</code> objects are represented in the <code>div#posts</code> element.

With the cursor inside the <code>assert_select</code>:

Type <code>ass</code>, press TAB, type <code>div.post</code>, press TAB, press TAB again, and type <code>count</code> (to replace the <code>text</code>). Now press TAB again, and type <code>@posts.size</code>. Press TAB a final time (it will highlight the <code>do...end</code> block), and press DELETE.

Our test method is now finished:

<pre syntax="ruby">def test_should_get_index
  get :index
  assert_response :success
  assert(posts = assigns(:posts), "Cannot find @posts")
  assert_select 'div#posts' do
    assert_select 'div.post', :count => posts.size
  end
end</pre>

Now we create a test for the 'show' action. Type deftg and 'show', and then 'post'. Then tab into 'fixture_name' and delete it. Now we'll autocomplete on fixtures again. Alt+Esc and select 'published'.

Now copy the 'div.post' assert_select line for this test, but change the :count to 1.

To run our functional tests, use Ctrl+\.

h2. Controllers and Routing

Similarly to navigating between model and unit test files, you can toggle between functional tests and controllers via Alt+Cmd+DownArrow.

In the controller, type <code>index</code> and use Shift+Enter to convert it to a method. Press BackSpace to delete the arguments.

To load all Posts:

<pre syntax="ruby">@posts = Post.fina</pre>

Pressing TAB creates <code>find(:all, :conditions => [...])</code>. Tab and change 'field' to 'published'.

h3. Diagram: fina - find(:all); finf - find(:first); fini - find(id); ^-| - params[:id]

Now create a 'show' action, with @post = Post.fini + tab. Use ^-| to insert params[:id].

We'll come back and look at views for our index action later. Instead, let's create a controller for creating + updating posts for the admin of the site.

We could use the scaffold generator to create a posts controller, with functional tests and default views. Instead, we'll build this controller from the ground up.

h3. Diagram: Navigation between file types

Shift+Alt+Cmd+DownArrow:

TODO - finish this

* post.rb -> post_test.rb, posts_controller.rb, etc
* post_test.rb -> post.rb, posts_controller.rb, etc

h3. Diagram: views/users/show.rhtml -> user_controller.rb; views/users/show.html.erb -> users_controller.rb

One thing to note for developers of Rails apps using older versions of Rails. If you are in a template file with the extension .rhtml, then it will navigate to the singular controller name 'post', rather than the plural default for controllers. This is for backwards compatibility with older naming conventions.

So we can create a new <code>posts_controller.rb</code> by returning to the post.rb or post_test.rb files, and navigating to the matching controller. It doesn't exist so a blank file is created.

We have a simple way to create new controller classes; the <code>cla</code> snippet has a 'Create controller class' option. Select that, and type 'Posts' and then 'post' to create our posts_controller.rb class.

For simpler actions, use the standard techniques for new methods, def + 'new' to create the 'new' method.

For some of the common, more complex controller actions there are also snippets. For the create action, type 'defcreate' and fill out the template with 'post'.

What I want the 'create' action to do is redirect back to the main blog page for

Now change the redirect from <code>@post</code>, to <code>public_post_path(@post)</code>. That


h2. Views


h2. Extending